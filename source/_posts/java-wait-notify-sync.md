title: java 为什么wait(),notify(),notifyAll()必须在同步方法/代码块中调用？
date: 2015-12-05 17:29:10
tags: [thread,object]
categories: [初级]
---
在Java中，所有对象都能够被作为"监视器`monitor`"——指一个拥有`一个独占锁`，`一个入口队列`和`一个等待队列`的实体entity。所有对象的非同步方法都能够在任意时刻被任意线程调用，此时不需要考虑加锁的问题。而对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程能够调用它们。例如，一个同步方法是独占的。如果在线程调用某一对象的同步方法时，对象的独占锁被其他线程拥有，那么当前线程将处于阻塞状态，并添加到对象的入口队列中。

只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。这一点通常不会被程序员注意，因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，那么你将得到一个`java.lang.IllegalMonitorStateException:current thread not owner`。

当一个线程正在某一个对象的同步方法中运行时调用了这个对象的wait方法，那么这个线程将释放该对象的独占锁并被放入这个对象的等待队列。注意，wait()方法强制当前线程释放对象锁。这意味着**在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。**因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。

当某线程调用某对象的notify()或notifyAll()方法时，任意一个(对于notify())或者所有(对于notifyAll())在该对象的等待队列中的线程，将被转移到该对象的入口队列。接着这些队列将竞争该对象的锁，最终获得锁的线程继续执行。如果没有线程在该对象的等待队列中等待获得锁，那么notify()和notifyAll()将不起任何作用。**在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。**因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。

对于处于某对象的等待队列中的线程，只有当其他线程调用此对象的notify()或notifyAll()方法时才有机会继续执行。

调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:"特殊状态已经被设置"。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。

例如，生产者线程向缓冲区中写入数据，消费者线程从缓冲区中读取数据。消费者线程需要等待直到生产者线程完成一次写入操作。生产者线程需要等待消费者线程完成一次读取操作。假设wait(),notify(),notifyAll()方法不需要加锁就能够被调用。此时消费者线程调用wait()正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用notify()方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的wait(),notify(),notifyAll()方法必须在该对象的同步方法或同步代码块中被互斥地调用。
